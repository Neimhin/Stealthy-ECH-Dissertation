\section{SECH 2: Static Secret Shared OOB}
\subsection{Motivations and Deployment Scenarios}

The amount of `cover' available in the TLS 1.3 \var{ClientHello} message in which we can hide information without differentiating the message from an a normal TLS 1.3 message is limited. By using only a symmetric encryption algorithm as the basis for sending the stealthy information there is a smaller overhead than there would be with PKC or HPKE.

With the \var{random} and \var{legacy\_session\_id} fields we get a contiguous sequence of 64 octets. Other fields/extensions with values that {\em may} look random (and thus might provide cover) are the cipher suite GREASE values, the PSK identity, the \var{key\_share} itself. However, the cover provided by these fields/extensions would be less certain because they differ across situations/implementations of TLS. Using these effectively as cover for stealthy bits would involve mimicking the behaviour of a specific implementation in order not to stick out.

[ ] if the client and server can share the OOB secret securely then we can implement a highly stealthy and cryptographically secure inner SNI

[ ] since the server does not have to publish a public key (as in ECH), it is possible to hide the fact that the server is support SECH from all except the client who knows the OOB secret

[ ] the secret could be shared amongst multiple clients, allowing for some scale of deployment, but this protocol is certainly not appropriate for internet scale deployments (millions of clients). The more widely the secret is shared the more likely it is to be leaked.

[ ] This design is NOT forward secret. If the shared secret is compromised then 

\subsection{Design}

We assume the client and client-facing server have some way to securely share a secret out-of-band; call this secret $s$ or \var{sech2\_long\_term\_key}. The shared secret should be a random string of at least 32 octets, or a longer string with at least that much entropy.


The client wishes to communicate \var{sech\_inner\_servername} secretly and stealthily to the client-facing server. Due to the limited amount of `cover' in the \var{ClientHello} the maximum length of \var{sech\_inner\_servername} is \sechtwoservernamelen. The \var{sech\_inner\_servername} is padded with a suffix of zeros to yield \var{padded\_servername} which is \sechtwoservernamelen octets long.  The client also generates a session-specific \sechtwoivlen{} octet \nonce. The plain text for encryption $pt$ is the \sechtwoservernamelen{} octet \var{padded\_servername}.
The session SECH 2 encryption key $sk_c$=\var{sech\_session\_secret} is computed as defined in \ref{lst:sech2-derive-secret}.
The client should ensure that it has never used the $(\nonce,sk_c)$ pair before, but ensuring that $(\nonce,sk_c)$ are never reused globally may not be feasible. Ideally the $(\nonce,sk_c)$ should never be used twice by any clients, but if there a multiple clients that do not coordinate this will be impossible to guarantee.


We note that the \var{random} and \var{legacy\_session\_id} are contiguous giving us a contiguous string of 64 octets in which we hide the SECH 2 offer, and we call this contiguous string $c$ for `cover'. The AEAD encrypted text has length \sechtwocipherlen{} and is placed in bytes \sechtwocipheroffset{}  to \sechtwocipherend{} of $c$, as depicted in Figure~\ref{fig:sech2-cover}, yielding \var{\ClientHelloOuter}.

We define \var{ClientHelloOuterContext} as a clone of \var{ClientHelloOuter}, except with bytes 12 to 64 of the cover $c$ set to 0s. The session key $sk_c$ can only be computed after \var{Client\-HelloOuterContext} is known.
The secure derivation of $sk_c$ depends on the entropy of the \var{key\_share} extension included in \var{ClientHelloOuterContext}.
[ ] TODO: what if key\_share is not included, e.g. for PSK-only handshake? Reject SECH?

The additional authenticated data $aad$ is empty.

%the transcript of \var{ClientHelloInner} message, which is \var{ClientHelloOuter} but with: 1. the encrypted AEAD output replaced with the plain text \var{sech\_inner\_servername} and \var{sech\_inner\_random}, as well as 2. the \var{extension\_data} field of the \var{server\_name} extension set to all 0s with the same length as the cover value for \var{server\_name} (The backend server does not learn the cover SNI used). The AEAD MAC $t$ is left in \var{ClientHelloInner}.

\begin{listing}[htb]
\centering
\includegraphics[width=\linewidth]{figure/sech2-derive-secret.pdf}
\captionsetup{width=.8\linewidth} 
\caption[SECH 2 Derive Secret]{Derive $sk_c$, the secret key that will be used by the client to encrypt $pt$ which has the inner \var{CH} data.}
\label{lst:sech2-derive-secret}
\end{listing}

The client encrypts $pt$ (authenticating $aad$) with $(\nonce,sk_c)$ using AES-128-GCM, producing a \sechtwotaglen{} octet authentication tag $t$ and the \sechtwocipherlen{} octet encrypted text $ct$. The \var{\ClientHelloOuter} has $c:=\nonce||ct||t$. The placement of the required values in cover $c$ of the \var{\ClientHelloOuter} is depicted in Figure~\ref{fig:sech2-cover}.

\begin{figure}[htb]
\centering
\includegraphics[width=\linewidth]{figure/sech2-cover.pdf}
\captionsetup{width=.8\linewidth} 
\caption[SECH 2 Cover]{Locations of AEAD inputs and outputs in the 64 contiguous octets of \var{ClientHello} \var{random} and \var{legacy\_session\_id}. The cipher text $ct$ and MAC tag $t$ outputs are a function of $iv$, $s$, $pt$, and $aad$: $(ct,t)=\text{AEAD}(iv,s,pt,aad)$.}
\label{fig:sech2-cover}
\end{figure}

A cooperating server in possession of $s$ that receives a \var{ClientHello} first constructs \var{ClientHelloOuterContext}, then $sk_c$, and should attempt to decrypt and authenticate $ct$. If decryption/authentication are unsuccessful the server continues with the TLS 1.3 handshake as normal. If successful, the client-facing server forwards \var{ClientHelloInner} to the backend server identified by the inner server name. If the inner server name does not identify a backend server then the client-facing server continues the TLS 1.3 handshake as if SECH 2 is disabled.

The \var{ClientHelloInner} message  is \var{ClientHelloOuter} but with: 1. the encrypted AEAD output $ct$ replaced with the plain text $pt$, as well as 2. the \var{extension\_data} field of the \var{server\_name} extension set to all 0s with the same length as the cover value for \var{server\_name} (The backend server does not learn the cover SNI used). The AEAD MAC $t$ is left in \var{ClientHelloInner}.

The backend server can distinguish a \var{ClientHelloInner} from a regular regular \var{ClientHello} by the \var{server\_name} extension. If the \var{extension\_data} field of the \var{server\_name} has all 0s it is a \var{ClientHelloInner}. Otherwise it should be treated as a regular TLS 1.3 hello.

The server parses the plaintext $pt$ to retrieve the inner server name in order to select an identity. At this point the backend server might respond with \var{HRR} or \var{ServerHello}. Whereas in ECH the acceptance signal is always sent in the server's first message (whether it is a \var{HRR} or \var{SH}), for SECH 2 the acceptance signal is always in the \var{SH}. The client-facing server forwards these (and subsequent) messages to the client unaltered. In the case of \var{HRR} the backend server creates a normal \var{HRR} response and the client constructs \var{ClientHello2} as specified in RFC 8446 (\cite{rfc8446}). If the backend server accepts the parameters of \var{ClientHello} (or \var{ClientHello2} in the case of \var{HRR}) and accepts the inner servername identified in $pt$, then it responds with a special \var{ServerHello} containing an SECH acceptance signal. Also, if using certificate-based authentication, then the later \var{Certificate} message should contain a certificate identified in $pt$.

The SECH 2 acceptance signal is 8 octets long and placed in the last 8 bytes of the \var{ServerHello.random}. It is a function of the transcript of the handshake so far, \var{sech\-\_\-transcript\_hash}, and $s=$\var{sech2\_long\_term\_key}. We define \var{sech\_accept\_confirmation} in Listing~\ref{lst:sech2-accept-function} and \var{sech\_transcript\_hash} in Listing~\ref{lst:sech2-transcript-hash}.

\begin{listing}[htb]
\centering
\includegraphics[width=.7\linewidth]{figure/sech2-accept-function.pdf}
\captionsetup{width=.8\linewidth} 
\caption[SECH 2 Accept Confirmation]{The function used to calculate the SECH 2 acceptance signal using the \var{HKDF-Expand-Label} function defined in Section 7.1 of RFC 8446 (\cite{rfc8446}). The \var{sech\_early\_secret} is derived from $s$ as defined in Listing~\ref{lst:sech2-derive-secret}, and \var{sech\_transcript\_hash} is described in Listing~\ref{lst:sech2-transcript-hash}.}
\label{lst:sech2-accept-function}
\end{listing}

\begin{listing}[htb]
\centering
\includegraphics[width=\linewidth]{figure/sech2-transcript-hash.pdf}
\captionsetup{width=.8\linewidth} 
\caption[SECH 2 Transcript Hash]{Specification of the \var{sech\_transcript\_hash} used to calculate \var{sech\_accept\_confirmation}. The \var{algorithm} is the hash algorithm of the negotiated cipher suite for the handshake.}
\label{lst:sech2-transcript-hash}
\end{listing}

% The client uses that secret to encrypt the true target servername as well as a 32 byte secret inner nonce which are hidden in the ClientHello \var{random} and the \var{pre\_shared\_key} extension. The inclusion of the secret inner nonce is necessary to mitigate cut-and-paste attacks.

% More precisely, the client generates a 12 byte initialisation vector for AES-128-GCM. The plaintext is an ASCII encoding of the servername padded with 0x00 up to 12 bytes, appended to the 32 byte inner nonce.
% AEAD is used but the AAD is 0-length. % TODO: might be better to use the transcript hash of ClientHello (with random zeroed) as AAD, (however, if random is zeroed then transcript hash might not change)
% The AEAD tag is truncated to 8 bytes, such that we have a combined 64 bytes to send, which are put into the \var{ClientHello.random} and \var{ClientHello.legacy\_session\_id}. The first 12 bytes contain the IV, the next 12 contain the first 12 bytes of the cipher text, and the last 8 bytes of the \var{random} contain the truncated MAC, and the \var{ClientHello.legacy\_session\_id} is the last 

If the backend server accepts SECH 2 then it makes the SECH inner servername available to the application program via a callback or some other means, which allows the application program to decide whether or not to switch contexts (server certificate etc.).

\subsubsection{SECH 2 with PSK}
If a server accepts SECH 2 it may issue a ticket referencing a PSK that can be used to resume with backend server without stealthy encryption.

The PSK is derived as defined in Listing~\ref{lst:sech2-psk}, which differs from the definition of the PSK defined RFC 8446 in that the label is \var{``sech res''} rather than \var{``resumption''}. This ensures that the standard TLS 1.3 PSK is only used for a connection to the outer servername, whereas the \var{sech2\_psk} is only used for the inner servername.
\begin{listing}
\begin{verbatim}
sech2_psk = HKDF-Expand-Label(
    resumption_master_secret,
    "sech res",
    ticket_nonce,
    Hash.length)
\end{verbatim}
\caption{\label{lst:sech2-psk}Definition of the PSK used when resuming an SECH 2 session.}
\end{listing}

Note that this definition of \var{sech2\_psk} is a function of the \var{resumption\_master\_secret}, which is not available to a client-facing server in split-mode.
Therefore, this type of resumption is not possible in split-mode. % TODO: design PSK resumption for split mode
% TODO: what if sech2_psk and psk are the same, e.g. because they collide when using different ticket_nonces? maybe the label should still be "sech res" but each ticket_nonce should be marked as either sech or non-sech?

To use a resumption PSK (sent via \var{NewSessionTicket}) in TLS 1.3 the PSK has to be validated with a \var{BinderEntry} which binds the PSK cryptographically to the transcript of the first handshake as well as most of the \var{CH} for the second handshake. Pseudocode for this process is presented in Listing~\ref{lst:binder-pseudocode}, but this process is not used in SECH 2, as explained below.

\begin{listing}
    \begin{verbatim}
early_secret = HKDF-Extract(0, PSK)
binder_key = Derive-Secret(early_secret, "res binder", "")
binder_finished_key = HKDF-Expand-Label(
    binder_key,
    "finished",
    "",
    Hash.length)
binder =
    HMAC(binder_finished_key,
        Transcript-Hash(
            HandshakeContext1..ClientHello))
    \end{verbatim}
    \captionsetup{width=.8\linewidth} 
    \caption{\label{lst:binder-pseudocode}Pseudocode of the process used to compute a \var{binder} when using a resumption PSK. The \var{HandshakeContext1} is the transcript of the handshake in which the PSK was derived, and \var{ClientHello} is for a new connection and is truncated so as not to include the \var{binders} list itself. This formulation is tweaked slightly in the case of SECH 2.}
\end{listing}

\subsection{Distributing SECH 2 access without sharing \var{sech2\-\_long\-\_term\_secret}}
[ ] TODO research has anyone done ticket sharing amongst clients before? E.g. client with multiple processes

[ ] TODO bleichenbacher attack

Sharing the SECH 2 long term secret widely amongst clients would violate the `Avoid Widely Shared Secrets' requirement advocated by \citep{rfc8744-issues}. How do we facilitate connections from large numbers of clients while restricting each long term secret to being shared to only 2 parties? One option is to have a distinct long term secret for each client-server pair. The SECH 2 design specified here can facilitate this through trial decryption, i.e. every \var{ClientHello} processed by the server is checked against each registered secret until one is found to successfully decrypt the inner server name. This approach scales horribly, with the cost of every connection being proportional to the number of registered clients, whether or not those clients are active. But note that this trial decryption process is highly parallelizable.

Another approach is to modify the TLS 1.3 session resumption mechanism in order to allow a client to distribute PSKs to other clients. Those other clients could then resume the first client's session in order to access the backend server.

When a servers generates a \ac{PSK} and shares it in a \ac{NST} message, then (in TLS 1.3) \ac{PSK} is of type ``resumption'', rather than ``external''. Using ``resumption'' tickets/\acp{PSK} has a few extra steps compared to ``external'' \acp{PSK}. The calculation of the \var{binder} when using ``resumption'' incorporates the transcript of messages from the first session as well as initial messages from the new session, whereas without an external \ac{PSK} there is no `first' session so the transcript is just of the first session.

We consider now the scenario where a client (C1) completes an SECH 2 handshake in order to establish a PSK, but wishes to pass the PSK to a different client (C2) so that C2 can connect to the backend server stealthily without knowing the \var{sech2\_long\_term\_key}. One approach would be to treat the \ac{PSK} as ``resumption'' type. This would require the \var{binder} value in Listing~\ref{lst:binder-pseudocode} which is a function of the PSK and the transcript up to and including the new \var{ClientHello}. For resumption \acp{PSK} \var{Handshake Context 1} is the transcript of the first session's handshake, whereas for external \acp{PSK} \var{Handshake Context 1} is the empty string. Typically the \var{HandshakeContext1} is private because it contains decrypted confidential handshake messages, and therefore should not be shared with the other untrusted client C2. At the same time, in order to compute a valid \var{ClientHello} the private component of the \var{key\_share} is needed, and this value should not be accessible to C1 when C2 is resuming the session. In other words C1 should have exclusive access to the first part of the transcript, and C2 must generate the second part of the transcript. Therefore, in order to calculate the \var{binder} while maintaining these rules C2 would have to send the new \var{ClientHello} to C1. This is highly inconvenient operationally; it means that C1 would have to remain live and accessible in order for C2 to use the \ac{PSK}. For these reasons we deem that using \acp{PSK} of type ``resumption'' to bootstrap a second client is not viable.

\begin{listing}
    \begin{verbatim}
binder =
    HMAC(binder_key,
        Transcript-Hash(Handshake Context1,
        ClientHello) )
    \end{verbatim}
    \captionsetup{width=.8\linewidth} 
    \caption{\label{lst:binder-sech2-pseudocode}Normal calculation of \var{binder} in TLS 1.3.}
\end{listing}

While binding the bootstrap \ac{PSK} to the session in which it was generated is desirable, and it would be more congruent with the existing TLS 1.3 spec (\acp{PSK} delivered by \ac{NST} are bound in this way), we instead opt to treat bootstrap \acp{PSK} more like `external' keys. The calculation of the \var{binder} is simplified as in Listing~\ref{lst:binder-sech2-pseudocode-ext}. By acquiring from C1 just the \ac{PSK} value itself and the associated hash algorithm C2 has enough information to use the \ac{PSK}.

\begin{listing}
    \begin{verbatim}
binder =
    HMAC(binder_key,
        Transcript-Hash(ClientHello))
    \end{verbatim}
    \captionsetup{width=.8\linewidth} 
    \caption{\label{lst:binder-sech2-pseudocode-ext}Calculation of \var{binder} for SECH 2 bootstrap \acp{PSK}.}
\end{listing}

%[ ] The server uses the 32 byte shared secret key as well as the decrypted inner servername to create an 8 byte acceptance signal which is hidden in the ServerHello.random. The 8 byte acceptance signal is computed as \var{sech\_accept\_confirmation = AEAD-encrypt(IV, plaintext="", aad=sech\_inner\_servername, accept\_key).tag}, where IV is the first 12 bytes of the ServerHello.random (uniformly randomly generated), the plaintext is zero-length, the AAD is precisely the inner servername (which does not need to be transmitted because it is known by the client), and \var{accept\_key} is a session-specific key derived using HKDF from the session's master secret and the transcript of ClientHello..ServerHello, but with the last 16 bytes of ServerHello.random set to 0x00. The last 8 bytes of \var{ServerHello.random} are possibly used for an ECH acceptance signal, and the ECH acceptance signal is computed based on the transcript of ClientHello..ServerHello, except with the last 8 bytes of of ServerHello.random set to 0x00. Therefore, if the server is sending an SECH acceptance signal *and* an ECH acceptance signal, the SECH acceptance signal is computed first because the ECH acceptance signal is defined to incorporate the SECH acceptance signal bytes in its transcript hash. To construct the 8 sech\_accept\_confirmation bytes we make use of the HKDF-Expand-Label function defined in RFC 8446 Section 7.1.
    % ```c
    % md = TranscriptHash(ClientHello..ServerHello) // with last 16 bytes of ServerHello.random set to 0x00
    % padded\_sech\_IV = pad(sech\_IV, HashLen)
    % sech\_accept\_confirmation = HKDF-Expand-Label(
    %   HKDF-Extract(padded\_sech\_IV, sech\_symmetric\_key),
    %   "sech ac" || 0x00 || sech\_decrypted\_inner\_servername,
    %   md,
    %   8
    % )
    % ```

\subsection{Design Differences Between SECH 2 and ECH}
[ ] The acceptance signal is always sent in the \var{ServerHello}

[ ] This definition of \var{sech\_accept\_confirmation} is essentially a modification of the ECH \var{accept\_confirmation} defined in Section 7.2 of [TODO cite ECH draft], which we repeat here:
% ```
%   accept\_confirmation = HKDF-Expand-Label(
%     HKDF-Extract(0, ClientHelloInner.random),
%     "ech accept confirmation",
%     transcript\_ech\_conf,
%     8
%   )
% ```

The ECH \var{accept\_confirmation} uses \var{HKDF-Extract(0, ClientHelloInner.random)} as the `Secret' passed to \var{HKDF-Expand-Label}, and \var{HKDF-Extract(0,ClientHelloInner.random)} is confidential (only known to the client and server) because the \var{ClientHelloInner.random} was in the {\em encrypted} \var{ClientHelloInner}. Also, it is essential that \var{accept\_confirmation} can be generated by the backend server in ECH split mode, which is why the salt passed to \var{HKDF-Extract} is the 0 string. While it would be more secure to use a session-specific random value as the salt for \var{HKDF-Extract}, we cannot use the \var{ClientHelloOuter.random} because this value is not available to the backend server (the backend server only processes the ClientHelloInner). The HKDF specification assumes that the salt and IKM passed to HKDF-Extract are indepedent of each other (Section 3.4 RFC 5869), and in particular that the salt values are not `chosen or manipulated by an attacker'.
Since \var{ClientHelloOuter.random} is never processed by the backend server it will not be incorporated into the \var{Finished} message, which means it is not protected from tampering in split-mode. This means an attacker could manipulate \var{ClientHelloOuter.random} and so it should not be used as the salt for \var{HKDF-Extract}.

[ ] In order to facilitate a split mode of operation in a similar fashion to ECH it must be possible for the SECH backend server to produce  the \var{sech\_accept\_confirmation} signal. For the signal described above this entails that the backend server must possess the \var{sech\_symmetric\_key}, meaning \var{sech\_symmetric\_key} would be shared amongst three parties; client, client-facing server, backend server. This violates one of the design requirements listed in Section 3.2 by \cite{rfc8744-issues}; Avoid Widely Shared Secrets.
% \subsection{Security Considerations}

[ ] High probability for situations where an attacker can guess the plaintext, or where there are only a small number of possible plaintexts (SNIs). How does this affect capacity to brute force the secret key? -> Does this mean the SNIs must also remain secret?

\subsection{Implementation Notes}

[ ] Error handling
\subsection{Testing}